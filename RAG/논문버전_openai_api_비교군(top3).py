# -*- coding: utf-8 -*-
"""논문버전_Openai API_비교군(TOP3).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oufQxowlmVKXrv63RZEY5-vaYIuZFnZ0
"""

!pip install -U langchain langchain-community
!pip install chromadb
!pip install tiktoken

# ✅ 1. 필수 라이브러리
import os
import pandas as pd
from langchain.vectorstores import Chroma
from langchain.embeddings import OpenAIEmbeddings
from langchain.chat_models import ChatOpenAI
from langchain.prompts.chat import ChatPromptTemplate, SystemMessagePromptTemplate, HumanMessagePromptTemplate
from langchain.chains import LLMChain
from langchain.schema import Document

# ✅ 2. OpenAI API 키
os.environ["OPENAI_API_KEY"] = "sk-..."  # 본인의 키로 교체

# ✅ 3. CSV 기반 딕셔너리 RDB 구성
rdb_path = "광역시 호텔 정보_개요없음.csv"
df = pd.read_csv(rdb_path)
df = df.drop(columns=[col for col in df.columns if "Unnamed" in col])  # 불필요한 열 제거
df.fillna("", inplace=True)  # 결측값 빈 문자열 처리

# 딕셔너리 변환
숙소정보 = {
    row["명칭"]: {
        "주소": row["주소"],
        "객실유형": row["객실 유형"],
        "주차가능": row["주차 가능"],
        "레스토랑": row["레스토랑"],
        "부대시설": row["부대 시설"]
    }
    for _, row in df.iterrows() # 위 딕셔너리 구조를 DataFrame의 모든 행에 대해 반복적으로 생성, iterrows는 Pandas 메서드
}

# ✅ 데이터 불러오기
df = pd.read_csv("개요만.csv").fillna("")

# ✅ 문서 리스트 구성 (개요만 page_content로 사용)
docs = []
for _, row in df.iterrows():
    숙소명 = row["숙소명"]
    개요 = row["개요"]
    doc = Document(page_content=개요, metadata={"숙소명": 숙소명})
    docs.append(doc)

# ✅ 벡터DB 저장
embedding = OpenAIEmbeddings()
vectordb = Chroma.from_documents(docs, embedding, persist_directory="./chroma_db")
vectordb.persist()
print("✅ VectorDB 저장 완료: ./chroma_db")

# ✅ 5. 메시지 프롬프트 구성 (강화 버전)
system_template = """
당신은 광역시 호텔 숙소 추천 도우미입니다.

아래는 후보 숙소 목록입니다. 사용자의 질문을 읽고, 가장 적절한 숙소 1개만 추천해 주세요.
**반드시 context에 제공된 정보만을 바탕으로 판단해야 합니다.**

출력 시 반드시 다음 조건을 지켜 주세요:

1. 숙소명만 출력하며, 설명은 쓰지 마세요.
2. 출력 형식은 반드시 아래와 같아야 합니다.
3. 추천할 숙소가 없으면 '추천 실패'라고 출력하세요.

출력 예시:
추천 숙소: 광안리게스트하우스
"""

system_msg = SystemMessagePromptTemplate.from_template(system_template)
human_msg = HumanMessagePromptTemplate.from_template("{context}\n\n[사용자 질문]\n{question}")
chat_prompt = ChatPromptTemplate.from_messages([system_msg, human_msg])
llm = ChatOpenAI(model_name="gpt-4o", temperature=0.7)
llm_chain = LLMChain(prompt=chat_prompt, llm=llm)

# ✅ context 구성 함수 (개요 제외 버전)
def build_context(hotel_names, db_dict):
    context = ""
    for name in hotel_names:
        info = db_dict.get(name, {})
        context += f"[숙소명] {name}\n[주소] {info.get('주소')}\n\n"
    return context.strip()

# ✅ 7. 최종 추천 함수
def recommend(user_query, top_k=10): # user_query: 사용자가 실제로 입력한 자연어 질문, top_k: 벡터 검색으로 유사한 질문을 몇 개까지 찾을 것인지
    docs = vectordb.similarity_search(user_query, k=top_k) # 이 줄은 사용자의 질의와 가장 유사한 질문을 벡터 기준으로 검색
    추천숙소들 = list({doc.metadata["숙소명"] for doc in docs}) # 위에서 가져온 Document들에서 숙소명만 set으로 뽑고, 중복 제거, 이유는 중복 제거 + 순서 보존
    context = build_context(추천숙소들, 숙소정보) # 위에서 정의한 context 구성 함수 사용
    return llm_chain.run({"context": context, "question": user_query}) # LLM 호출, 전달된 context + 사용자 질문을 합쳐서 GPT 모델이 응답을 생성

import pandas as pd
import re

# ✅ 평가질의 불러오기
eval_df = pd.read_csv("평가질의_TFIDF순위_최종.csv")

# ✅ LLM 응답에서 숙소명 3개 추출 함수 (형식 강화 대응)
def parse_recommendation(response_text):
    lines = response_text.strip().splitlines()
    result = []
    for line in lines:
        match = re.match(r"\d+\.\s*(.+)", line)
        if match:
            result.append(match.group(1).strip())
    # 부족할 경우 '추천 실패'로 채우기
    while len(result) < 3:
        result.append("추천 실패")
    return result[:3]

# ✅ 자동 평가 실행
auto_results = []

for idx, row in eval_df.iterrows():
    query = row["질의"]
    try:
        response = recommend(query)  # LLM 호출
        top3 = parse_recommendation(response)
    except Exception as e:
        print(f"[{idx}] 에러 발생: {e}")
        top3 = ["추천 실패", "추천 실패", "추천 실패"]

    auto_results.append({
        "질의": query,
        "포함핵심어": row["포함핵심어"],
        "포함개수": row["포함개수"],
        "추천_숙소1": top3[0],
        "추천_숙소2": top3[1],
        "추천_숙소3": top3[2]
    })

# ✅ 결과 저장
auto_df = pd.DataFrame(auto_results)
auto_df.to_csv("평가결과_RAG추천자동화(비교군).csv", index=False, encoding="utf-8-sig")